<style id="plugin-css-3d-dices" class="plugin-css">
</style>

<script id="plugin-js-3d-dices-dep-1" class="plugin-js">
    {{ include_static("../node_modules/three/build/three.js") }}
</script>
<script id="plugin-js-3d-dices-dep-2" class="plugin-js">
    {{ include_static("../node_modules/cannon/build/cannon.js") }}
</script>
<script id="plugin-js-3d-dices-dep-3" class="plugin-js">
    {{ include_static("../node_modules/three/examples/js/controls/OrbitControls.js") }}
</script>
<script id="plugin-js-3d-dices-dep-4" class="plugin-js">
    {{ include_static("../node_modules/three/examples/js/libs/stats.min.js") }}
</script>
<script id="plugin-js-3d-dices-dep-5" class="plugin-js">
    {{ include_static("../node_modules/threejs-dice/lib/dice.js") }}
</script>

<script id="plugin-js-3d-dices" class="plugin-js">
    {
        // Example adapted from https://github.com/byWulf/threejs-dice/blob/master/examples/rolling.html

        // standard global variables
        let container, scene, camera, renderer, debug = false, world, dice = []
        const main_container = $('#main-container')

        init()

        function init(nbr_dices = 2) {
            // Scene
            scene = new THREE.Scene()
            scene.background = null

            // Camera
            let SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight
            let VIEW_ANGLE = 17, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR)
            scene.add(camera)
            camera.position.set(0, 100, 30)

            // Renderer
            renderer = new THREE.WebGLRenderer({antialias: true, alpha: true})
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT)
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.PCFSoftShadowMap
            renderer.setClearColor(0xFFFFFFFF, 0)

            // Canvas positioning
            container = $("<div style='position: absolute; left: 0; top: 0'></div>")
            main_container.append(container)
            container = main_container.children().last()
            container.append(renderer.domElement)

            // Lights
            let ambient = new THREE.AmbientLight('#ffffff', 0.3)
            scene.add(ambient)

            let directionalLight = new THREE.DirectionalLight('#ffffff', 0.5)
            directionalLight.position.x = -1000
            directionalLight.position.y = 1000
            directionalLight.position.z = 1000
            scene.add(directionalLight)

            let light = new THREE.SpotLight(0xefdfd5, 0.5)
            light.position.y = 100
            light.target.position.set(0, 0, 0)
            light.castShadow = true
            light.shadow.camera.near = 50
            light.shadow.camera.far = 110
            light.shadow.mapSize.width = 1024
            light.shadow.mapSize.height = 1024
            scene.add(light)

            // Floor
            let floorMaterial = new THREE.MeshPhongMaterial({color: '#00aa00', side: THREE.DoubleSide})
            let floorGeometry = new THREE.PlaneGeometry(30, 30, 10, 10)
            let floor = new THREE.Mesh(floorGeometry, floorMaterial)
            floor.receiveShadow = true
            floor.rotation.x = Math.PI / 2
            if (debug)
                scene.add(floor)
            camera.lookAt(floor.position)

            // walls
            let wallMaterial = new THREE.MeshPhongMaterial({color: '#0000aa', side: THREE.DoubleSide})
            let wallGeometry = new THREE.PlaneGeometry(30, 30, 10, 10)
            let wall = new THREE.Mesh(wallGeometry, wallMaterial)
            wall.rotation.y = Math.PI / 2
            wall.position.x = 15
            if (debug)
                scene.add(wall)

            let wallMaterial2 = new THREE.MeshPhongMaterial({color: '#aa00aa', side: THREE.DoubleSide})
            let wallGeometry2 = new THREE.PlaneGeometry(30, 30, 10, 10)
            let wall2 = new THREE.Mesh(wallGeometry2, wallMaterial2)
            wall2.rotation.z = Math.PI
            wall2.position.z = 15
            if (debug)
                scene.add(wall2)

            // Cannon setup
            world = new CANNON.World()
            world.gravity.set(0, -9.82 * 10, 0)
            world.broadphase = new CANNON.NaiveBroadphase()
            world.solver.iterations = 16
            DiceManager.setWorld(world)

            // Floor collisions
            let floorBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: DiceManager.floorBodyMaterial
            })
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
            world.add(floorBody)

            // Walls collisions
            let barrierBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: DiceManager.barrierBodyMaterial
            })
            barrierBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
            barrierBody.position.set(wall.position.x, wall.position.y, wall.position.z)
            world.add(barrierBody)

            let barrierBody2 = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: DiceManager.barrierBodyMaterial
            })
            barrierBody2.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI)
            barrierBody2.position.set(wall2.position.x, wall2.position.y, wall2.position.z)
            world.add(barrierBody2)

            // Dices
            let colors = ['#ff0000', '#ffff00', '#00ff00', '#0000ff', '#ff00ff']
            for (let i = 0; i < nbr_dices; i++) {
                let die = new DiceD6({size: 1.5, backColor: colors[i]})
                scene.add(die.getObject())
                dice.push(die)
            }

            function randomDiceThrow() {
                let diceValues = []

                for (let i = 0; i < dice.length; i++) {
                    let yRand = Math.random() * 20
                    dice[i].getObject().position.x = -15 - (i % 3) * 1.5
                    dice[i].getObject().position.y = 2 + Math.floor(i / 3) * 1.5
                    dice[i].getObject().position.z = -15 + (i % 3) * 1.5
                    dice[i].getObject().quaternion.x = (Math.random() * 90 - 45) * Math.PI / 180
                    dice[i].getObject().quaternion.z = (Math.random() * 90 - 45) * Math.PI / 180
                    dice[i].updateBodyFromMesh()
                    let rand = Math.random() * 5
                    dice[i].getObject().body.velocity.set(25 + rand, 40 + yRand, 15 + rand)
                    dice[i].getObject().body.angularVelocity.set(20 * Math.random() - 10, 20 * Math.random() - 10, 20 * Math.random() - 10)

                    diceValues.push({dice: dice[i], value: i + 1})
                }

                DiceManager.prepareValues(diceValues)
            }

            randomDiceThrow()

            requestAnimationFrame(animate)
        }

        function animate() {
            updatePhysics()
            renderer.render(scene, camera)

            requestAnimationFrame(animate)
        }

        function updatePhysics() {
            world.step(1.0 / 60.0)

            for (let i in dice) {
                dice[i].updateMeshFromBody()
            }
        }
    }

    function dispose_plugin_3d_dices() {
        // TODO
    }

    // Register the function (avoid typos here or the method won't be called)
    plugin_dispose_methods["3d-dices"] = dispose_plugin_3d_dices
</script>
